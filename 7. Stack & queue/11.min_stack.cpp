// min stack
// lets say we are given some numbers and we are pushing it in a stack
// nos are 18 19 29 15 16
// so we now element at top would be 16

// now we need a function called  get min which will return the minimum element inside of the stack at any given point of time
// so what we will do is that we will use a trick, a stack and a supporting stack
// so we will implement push and pop from normal stack
// and get min from supporting stack

// first push 18 into the stack
// since supporting stack is empty, push that into supporting stack 
// supporting stack will only store min element
// now if we recieve elements greater than the element at the top of suppoting stack, push them in ther normal stack only
// else if its less than or equal to top of supporting stack push it into both stacks

// while popping, pop from normal stack, but if element that is popped is also the element at the top of supporting stack
// pop it from there as well

// **********************************************************SECOND APPROACH O(1)********************************************************************

// without using extra space
// that is only using a variable

// so lets create a variable called int min element
// so we will use a normal stack for basic operation like push pop top, and then min element using stack

// if stack is empty, push it in stack as well as make it the min element
// if not empty, then we need to think a bit
// we need a mechanissm to keep a record of the variables which were before it, as during pop we could lose the cureent min element

// so if the scenario is ki current min element is 5, and we recieve 3
// we will make the minimum eleemnt as 3
// but in the stack, insted of pushing 3 we will push 2*3 - 5 = 1
// ie 2 *(new min element) - curr_min_element

// so this is how we can keep a track of this
// now when we will be pushing and we recieve lesser elements than 3, we will follow the same process


// pooping and top
// if element to be popped is gretaer than minimum element, pop it simply
// if not, this means current element is even smaller than minimum element
// this is an exception generated by our equation
// so this means the original number was the minimum number (say 3)
// and the previous minimum element would be 2(curr_min) - element at top of stack
// ?that is 2*3 - 1 = 5 
// which was indeed the case
// so this will be our new min elment

